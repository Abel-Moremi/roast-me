<!DOCTYPE html>
<html>
<head>
    <title>Test Audio Playback</title>
</head>
<body>
    <h1>Audio Playback Test</h1>
    <button id="playBtn">Play Audio</button>
    <div id="status"></div>
    <div id="error" style="color: red;"></div>

    <script>
        async function loadMockData() {
            const response = await fetch('./mock/output.txt');
            const json = await response.json();
            return json;
        }

        async function playAudio() {
            const statusDiv = document.getElementById('status');
            const errorDiv = document.getElementById('error');
            
            try {
                statusDiv.textContent = 'Loading audio data...';
                const mockData = await loadMockData();
                
                if (!mockData.audio) {
                    throw new Error('No audio field in mock data');
                }
                
                statusDiv.textContent = 'Audio data loaded. Length: ' + mockData.audio.length;
                
                // Initialize AudioContext
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Decode base64 to ArrayBuffer
                const base64Audio = mockData.audio;
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                statusDiv.textContent += '\nDecoded bytes: ' + bytes.length;
                
                // Convert PCM bytes to Float32Array for AudioBuffer
                // Audio is 16-bit PCM at 24kHz, mono
                const sampleRate = 24000;
                const numSamples = bytes.length / 2; // 16-bit = 2 bytes per sample
                const audioBuffer = audioContext.createBuffer(1, numSamples, sampleRate);
                const channelData = audioBuffer.getChannelData(0);
                
                statusDiv.textContent += '\nSamples: ' + numSamples;
                statusDiv.textContent += '\nDuration: ' + audioBuffer.duration + ' seconds';
                
                // Convert 16-bit PCM to float32 (-1.0 to 1.0)
                const view = new DataView(bytes.buffer);
                for (let i = 0; i < numSamples; i++) {
                    const sample = view.getInt16(i * 2, true); // true for little-endian
                    channelData[i] = sample / 32768.0; // Normalize to -1.0 to 1.0
                }
                
                // Create and start audio source
                const audioSource = audioContext.createBufferSource();
                audioSource.buffer = audioBuffer;
                audioSource.connect(audioContext.destination);
                
                audioSource.onended = () => {
                    statusDiv.textContent += '\nPlayback finished!';
                };
                
                audioSource.start(0);
                statusDiv.textContent += '\nPlaying...';
                
            } catch (error) {
                console.error('Error:', error);
                errorDiv.textContent = 'Error: ' + error.message + '\n' + error.stack;
            }
        }

        document.getElementById('playBtn').addEventListener('click', playAudio);
    </script>
</body>
</html>
